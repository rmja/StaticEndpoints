using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace StaticEndpoints.SourceGenerators;

[Generator]
public class EndpointRegistrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all types that implement IEndpoint
        var endpointTypes = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, _) => GetEndpointTypeIfValid(ctx)
            )
            .Where(static t => t is not null)
            .Collect();

        // Generate the registration code
        context.RegisterSourceOutput(
            endpointTypes,
            static (spc, endpoints) =>
            {
                if (endpoints.IsEmpty)
                    return;

                var source = GenerateEndpointRegistration(endpoints!);
                spc.AddSource("EndpointRegistration.g.cs", source);
            }
        );
    }

    private static INamedTypeSymbol? GetEndpointTypeIfValid(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;

        if (symbol == null)
            return null;

        // Check if implements IEndpoint
        var implementsIEndpoint = symbol.AllInterfaces.Any(i =>
            i.Name == "IEndpoint" && i.ContainingNamespace.ToDisplayString() == "StaticEndpoints"
        );

        if (!implementsIEndpoint)
            return null;

        // Must have AddRoute method
        var hasAddRoute = symbol
            .GetMembers("AddRoute")
            .OfType<IMethodSymbol>()
            .Any(m => m.IsStatic && m.Parameters.Length == 1);

        return hasAddRoute ? symbol : null;
    }

    private static string GenerateEndpointRegistration(ImmutableArray<INamedTypeSymbol> endpoints)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Routing;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        // Group endpoints by namespace for better organization
        var grouped = endpoints.GroupBy(e => e.ContainingNamespace.ToDisplayString());

        foreach (var group in grouped)
        {
            sb.AppendLine($"using {group.Key};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace Microsoft.AspNetCore.Routing;");
        sb.AppendLine();
        sb.AppendLine("public static partial class StaticEndpointsBuilderExtensions");
        sb.AppendLine("{");

        // Generate MapStaticEndpoints method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Maps all IEndpoint implementations discovered by source generator.");
        sb.AppendLine("    /// This method is AOT-compatible.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IEndpointRouteBuilder MapStaticEndpoints(");
        sb.AppendLine("        this IEndpointRouteBuilder app,");
        sb.AppendLine("        RouteGroupBuilder? routeGroupBuilder = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        var builder = routeGroupBuilder ?? app;");
        sb.AppendLine();

        foreach (var endpoint in endpoints.OrderBy(e => e.ToDisplayString()))
        {
            var fullName = endpoint.ToDisplayString();
            sb.AppendLine($"        {fullName}.AddRoute(builder);");
        }

        sb.AppendLine();
        sb.AppendLine("        return app;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
